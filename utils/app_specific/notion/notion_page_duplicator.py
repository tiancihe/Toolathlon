#!/usr/bin/env python3
"""
Notion Page Duplicator
======================

A standalone script to duplicate a specific child page from one parent page 
to another parent page using Playwright automation and Notion API.

Usage:
    python notion_page_duplicator.py \
        --source-parent "https://notion.so/your-source-page-url" \
        --child-name "Child Page Name" \
        --target-parent "https://notion.so/your-target-page-url" \
        --notion-key "your_notion_api_key" \
        --output-file "./duplicated_page_id.txt"

Requirements:
    - notion_state.json file (generated by notion login helper)
    - Playwright installed with browser
    - notion-client package
"""

import argparse
import re
import time
from pathlib import Path
from typing import Optional, Tuple

from notion_client import Client
from playwright.sync_api import Browser, Page, sync_playwright, TimeoutError as PlaywrightTimeoutError

from utils.mcp.tool_servers import MCPServerManager, call_tool_with_retry, ToolCallError
import asyncio
import json
import time

# Import the protection module
import sys
import os
sys.path.append(os.path.dirname(os.path.abspath(__file__)))
from notion_page_protector import NotionPageProtector

from configs.global_configs import global_configs
WITH_PLAYWRIGHT = global_configs.notion_preprocess_with_playwright # default as false

# Selectors for Notion UI elements (same as in the original code)
PAGE_MENU_BUTTON_SELECTOR = '[data-testid="more-button"], div.notion-topbar-more-button, [aria-label="More"], button[aria-label="More"]'
DUPLICATE_MENU_ITEM_SELECTOR = 'text="Duplicate"'
MOVE_TO_MENU_ITEM_SELECTOR = 'text="Move to"'
MOVE_TO_SEARCH_INPUT_SELECTOR = 'input[placeholder*="Move page to"], textarea[placeholder*="Move page to"]'

class NotionPageDuplicator:
    """Standalone Notion page duplicator using Playwright and Notion API."""
    
    def __init__(self, notion_key: str, browser: str = "firefox", headless: bool = True, state_path: str = "./configs/notion_state.json"):
        """
        Initialize the duplicator.

        Args:
            notion_key: Notion API integration token
            browser: Browser to use ("firefox" or "chromium")
            headless: Whether to run browser in headless mode
        """
        self.notion_client = Client(auth=notion_key)
        self.browser_name = browser
        self.headless = headless
        self.state_file = Path(state_path)
        self.duplicated_page_id = None  # Store the duplicated page ID

        # Initialize the protector
        self.protector = NotionPageProtector()

        if WITH_PLAYWRIGHT and not self.state_file.exists():
            raise FileNotFoundError(
                f"Authentication state file '{self.state_file}' not found. "
                "Please run the notion login helper first."
            )
    
    def extract_page_id_from_url(self, url: str) -> str:
        """Extract page ID from a Notion URL."""
        # Remove query parameters and fragments
        slug = url.split("?")[0].split("#")[0].rstrip("/").split("/")[-1]
        
        # Extract alphanumeric characters
        compact = "".join(c for c in slug if c.isalnum())
        
        if len(compact) < 32:
            raise ValueError(f"Could not parse page ID from URL: {url}")
        
        # Take last 32 characters and format as UUID
        compact = compact[-32:]
        return f"{compact[:8]}-{compact[8:12]}-{compact[12:16]}-{compact[16:20]}-{compact[20:]}"
    
    def find_child_page_by_name(self, parent_page_id: str, child_name: str) -> Optional[Tuple[str, str]]:
        """
        Find a child page by name under the given parent page.
        
        Returns:
            Tuple of (child_page_id, child_page_url) if found, None otherwise
        """
        try:
            # Get all child blocks of the parent page
            children = self.notion_client.blocks.children.list(block_id=parent_page_id)
            
            for child in children.get("results", []):
                if child.get("type") == "child_page":
                    # Get the child page details to check its title
                    child_page = self.notion_client.pages.retrieve(page_id=child["id"])
                    
                    # Extract title from page properties
                    props = child_page.get("properties", {})
                    title_prop = props.get("title", {}).get("title") or props.get("Name", {}).get("title")
                    
                    if title_prop:
                        title = "".join(t.get("plain_text", "") for t in title_prop).strip()
                        if title == child_name:
                            return child["id"], child_page.get("url", "")
            
            return None
            
        except Exception as e:
            print(f"Error finding child page '{child_name}': {e}")
            return None
    
    def get_page_title_by_id(self, page_id: str) -> str:
        """Get the title of a page by its ID."""
        try:
            page = self.notion_client.pages.retrieve(page_id=page_id)
            props = page.get("properties", {})
            title_prop = props.get("title", {}).get("title") or props.get("Name", {}).get("title")
            
            if title_prop:
                return "".join(t.get("plain_text", "") for t in title_prop).strip()
            return "Untitled"
            
        except Exception as e:
            print(f"Error getting page title for {page_id}: {e}")
            return "Unknown"
    
    def rename_page_via_api(self, page_id: str, new_title: str) -> bool:
        """Rename a Notion page using the API."""
        try:
            # First, get the current title for validation
            try:
                page = self.notion_client.pages.retrieve(page_id=page_id)
                props = page.get("properties", {})
                title_prop = props.get("title", {}).get("title") or props.get("Name", {}).get("title")
                current_title = "".join(t.get("plain_text", "") for t in title_prop).strip() if title_prop else "Untitled"
            except:
                current_title = "Unknown"

            # Validate the rename operation with protector
            is_valid, error_msg = self.protector.validate_rename_operation(page_id, current_title, new_title)
            if not is_valid:
                print(f"ERROR: {error_msg}")
                raise Exception(error_msg)

            # Proceed with rename
            self.notion_client.pages.update(
                page_id=page_id,
                properties={"title": {"title": [{"text": {"content": new_title}}]}},
            )
            print(f"Page renamed to: {new_title}")
            return True
        except Exception as e:
            print(f"Failed to rename page via API: {e}")
            return False

    def clear_modal_overlay(self, page: Page, timeout: int = 10_000) -> bool:
        """Try to clear modal overlay strategy"""
        modal_selector = "div.notion-modal-underlay"

        # Strategy 1: Wait 10 seconds to see if it disappears automatically
        try:
            page.wait_for_selector(modal_selector, state="detached", timeout=timeout)
            print("‚úÖ Modal overlay cleared automatically")
            return True
        except:
            print("‚ö†Ô∏è Modal overlay still present after 10s")

        # Strategy 2: Try to close by pressing ESC key
        try:
            page.keyboard.press("Escape")
            time.sleep(1)
            page.wait_for_selector(modal_selector, state="detached", timeout=2_000)
            print("‚úÖ Modal cleared by ESC key")
            return True
        except:
            print("‚ùå ESC key didn't work")

        # Strategy 3: Click outside the modal area
        try:
            # Click the blank area at the top left of the page
            page.click("body", position={"x": 50, "y": 50}, timeout=2_000)
            time.sleep(1)
            page.wait_for_selector(modal_selector, state="detached", timeout=2_000)
            print("‚úÖ Modal cleared by clicking outside")
            return True
        except:
            print("‚ùå Clicking outside didn't work")

        # Strategy 4: Refresh the page (last resort)
        try:
            print("üîÑ Refreshing page as last resort...")
            current_url = page.url
            page.goto(current_url, wait_until="load", timeout=30_000)
            time.sleep(3)
            print("‚úÖ Page refreshed successfully")
            return True
        except:
            print("‚ùå Page refresh failed")
            return False

    def duplicate_page_with_playwright(self, parent_of_source_page_url: str, source_page_url: str, target_parent_title: str, original_child_name: str) -> Optional[str]:
        """
        Duplicate a page using Playwright automation and move it to target parent.
        
        Args:
            source_page_url: URL of the page to duplicate
            target_parent_title: Title of the target parent page
            original_child_name: Original name of the child page (for renaming)
            
        Returns:
            URL of the duplicated page if successful, None otherwise
        """
        try:
            with sync_playwright() as p:
                browser_type = getattr(p, self.browser_name)
                browser: Browser = browser_type.launch(headless=self.headless)
                context = browser.new_context(storage_state=str(self.state_file))
                page = context.new_page()

                # Validate we're not duplicating FROM a protected page
                is_valid, error_msg = self.protector.validate_url_operation(source_page_url, "duplicate from")
                if not is_valid:
                    # It's OK to duplicate FROM a child of a protected page, just warn
                    print(f"WARNING: Duplicating from what might be related to a protected page: {source_page_url}")

                print(f"Navigating to source page: {source_page_url}")
                initial_url = page.url if hasattr(page, 'url') else None
                
                attempt_num = 0
                while attempt_num < 3:
                    page.goto(source_page_url, wait_until="load", timeout=60_000)
                    
                    # Wait for navigation to complete and verify we actually navigated
                    time.sleep(3)
                    page.wait_for_load_state("load", timeout=15_000)

                    # Verify we navigated to the correct page
                    current_url = page.url
                    print(f"Current URL after navigation: {current_url}")

                    # Extract the page ID from where we wanted to go
                    target_page_id = self.extract_page_id_from_url(source_page_url)
                    # Extract the page ID from where we actually are
                    current_page_id = self.extract_page_id_from_url(current_url)

                    # Check if we're on the right page
                    if current_page_id != target_page_id:
                        print(f"WARNING: Navigation verification failed!")
                        print(f"Expected to be on page: {target_page_id}")
                        print(f"Actually on page: {current_page_id}")

                        # Try one more time with a direct navigation
                        print("Retrying navigation...")
                        page.goto(source_page_url, wait_until="load", timeout=60_000)
                        time.sleep(25)

                        current_url = page.url
                        current_page_id = self.extract_page_id_from_url(current_url)

                        if current_page_id != target_page_id:
                            raise Exception(f"Failed to navigate to target page. Expected: {target_page_id}, Current: {current_page_id}")

                    print(f"Successfully verified navigation to target page: {current_page_id}")

                    # Save updated auth state
                    context.storage_state(path=str(self.state_file))

                    # Step 1: Duplicate the page
                    print("Opening page menu...")
                    page.wait_for_selector(PAGE_MENU_BUTTON_SELECTOR, state="visible", timeout=90_000)
                    page.click(PAGE_MENU_BUTTON_SELECTOR)
                    
                    print("Clicking 'Duplicate'...")
                    page.hover(DUPLICATE_MENU_ITEM_SELECTOR)
                    page.click(DUPLICATE_MENU_ITEM_SELECTOR)
                    
                    # Wait for duplication to complete (URL will change)
                    original_url = page.url
                    original_page_id = self.extract_page_id_from_url(original_url)
                    source_parent_id = self.extract_page_id_from_url(parent_of_source_page_url)
                    print(f"Original page ID before duplication: {original_page_id}")
                    print(f"Source parent ID: {source_parent_id}")
                    print("Waiting for duplication to complete...")

                    # Wait for URL to change from the original page
                    try:
                        page.wait_for_url(lambda url: url != original_url, timeout=600_000)
                        print("We have go to the new page!")
                        break
                    except PlaywrightTimeoutError:
                        attempt_num+=1
                        if attempt_num >= 3:
                            raise Exception("Failed to duplicate the page after 3 attempts")
                        print("Retrying duplication...")

                # Keep checking until we get to a page that is neither the original nor the source parent
                max_attempts = 10
                attempt = 0
                duplicated_page_id = None

                while attempt < max_attempts:
                    attempt += 1
                    time.sleep(2)  # Give Notion time to process

                    current_url = page.url
                    print(f"Attempt {attempt}: Current URL: {current_url}")

                    # Try to extract page ID from current URL
                    current_page_id = self.extract_page_id_from_url(current_url)

                    # Also check if there's a page ID in the URL fragment
                    fragment_page_id = None
                    if '#' in current_url:
                        fragment = current_url.split('#')[-1]
                        # Remove any query parameters from fragment
                        fragment = fragment.split('?')[0].split('&')[0]
                        # Extract alphanumeric characters from fragment
                        compact = "".join(c for c in fragment if c.isalnum())
                        if len(compact) >= 32:
                            # Take last 32 characters and format as UUID
                            compact = compact[-32:]
                            fragment_page_id = f"{compact[:8]}-{compact[8:12]}-{compact[12:16]}-{compact[16:20]}-{compact[20:]}"
                            print(f"Found page ID in fragment: {fragment_page_id}")

                    # Check if we have a valid new page ID
                    candidate_page_id = None
                    if current_page_id != original_page_id and current_page_id != source_parent_id:
                        candidate_page_id = current_page_id
                        print(f"Found new page ID in main URL: {candidate_page_id}")
                    elif fragment_page_id and fragment_page_id != original_page_id and fragment_page_id != source_parent_id:
                        candidate_page_id = fragment_page_id
                        print(f"Found new page ID in fragment: {candidate_page_id}")

                    if candidate_page_id:
                        # Verify this page actually exists by calling the API
                        try:
                            page_info = self.notion_client.pages.retrieve(page_id=candidate_page_id)
                            if page_info:
                                duplicated_page_id = candidate_page_id
                                print(f"‚úÖ Confirmed duplicated page ID: {duplicated_page_id}")
                                break
                        except Exception as e:
                            print(f"Page ID {candidate_page_id} verification failed: {e}")

                    print(f"Still waiting for valid duplicate page... (current: {current_page_id}, fragment: {fragment_page_id})")

                if not duplicated_page_id:
                    raise Exception(f"Failed to find valid duplicated page after {max_attempts} attempts")

                duplicated_url = page.url
                print(f"Page duplicated successfully: {duplicated_url}")

                self.duplicated_page_id = duplicated_page_id
                print(f"Duplicated page ID: {duplicated_page_id}")

                # Validate that we're not moving a protected page
                is_valid, error_msg = self.protector.validate_move_operation(
                    duplicated_page_id,
                    original_page_id,  # source parent (where it was duplicated)
                )
                if not is_valid:
                    print(f"ERROR: {error_msg}")
                    raise Exception(error_msg)

                # CRITICAL: Before moving, ensure we're on the duplicated page
                duplicated_page_url = f"https://www.notion.so/{duplicated_page_id.replace('-', '')}"
                current_url = page.url
                current_page_id = self.extract_page_id_from_url(current_url)

                if current_page_id != duplicated_page_id:
                    print(f"‚ö†Ô∏è Not on duplicated page (current: {current_page_id}, expected: {duplicated_page_id})")
                    print(f"Navigating to duplicated page: {duplicated_page_url}")

                    # Navigate to the duplicated page
                    page.goto(duplicated_page_url, wait_until="load", timeout=60_000)
                    time.sleep(3)
                    page.wait_for_load_state("load", timeout=15_000)

                    # Verify we're now on the correct page
                    current_url = page.url
                    current_page_id = self.extract_page_id_from_url(current_url)

                    if current_page_id != duplicated_page_id:
                        raise Exception(f"Failed to navigate to duplicated page. Expected: {duplicated_page_id}, Current: {current_page_id}")

                    print(f"‚úÖ Successfully navigated to duplicated page: {duplicated_page_id}")
                else:
                    print(f"‚úÖ Already on duplicated page: {duplicated_page_id}")

                # Step 2: Move the duplicated page to target parent
                print(f"Moving duplicated page to target parent: {target_parent_title}")

                # Clear modal state
                if not self.clear_modal_overlay(page):
                    raise Exception("Failed to clear modal overlay after all attempts")

                # Open page menu again
                page.wait_for_selector(PAGE_MENU_BUTTON_SELECTOR, state="visible", timeout=30_000)
                page.click(PAGE_MENU_BUTTON_SELECTOR)
                
                # Click "Move to"
                page.hover(MOVE_TO_MENU_ITEM_SELECTOR)
                page.click(MOVE_TO_MENU_ITEM_SELECTOR)
                
                # Fill in target parent title
                page.wait_for_selector(MOVE_TO_SEARCH_INPUT_SELECTOR, state="visible", timeout=15_000)
                search_input = page.locator(MOVE_TO_SEARCH_INPUT_SELECTOR).first
                search_input.click()
                search_input.fill("")  # Clear any existing text
                search_input.type(target_parent_title, delay=50)
                
                # Wait for search result and click it
                result_selector = f'div[role="menuitem"]:has-text("{target_parent_title}")'
                page.wait_for_selector(result_selector, state="visible", timeout=60_000)
                page.locator(result_selector).first.click(force=True)
                
                # Wait for move dialog to disappear
                page.wait_for_selector(MOVE_TO_SEARCH_INPUT_SELECTOR, state="detached", timeout=60_000)
                
                # Give Notion time to process the move
                time.sleep(3)

                # Step 3: Rename the duplicated page to remove any (1), (2) suffix
                print(f"Renaming duplicated page to original name: {original_child_name}")
                self.rename_page_via_api(duplicated_page_id, original_child_name)

                # Final validation: Check integrity of protected pages
                for protected_id, expected_title in self.protector.PROTECTED_PAGES.items():
                    try:
                        page_info = self.notion_client.pages.retrieve(page_id=protected_id)
                        props = page_info.get("properties", {})
                        title_prop = props.get("title", {}).get("title") or props.get("Name", {}).get("title")
                        current_title = "".join(t.get("plain_text", "") for t in title_prop).strip() if title_prop else "Unknown"

                        is_valid, warning = self.protector.verify_page_integrity(protected_id, current_title)
                        if not is_valid:
                            print(f"CRITICAL: {warning}")
                    except Exception as e:
                        print(f"WARNING: Could not verify protected page {protected_id}: {e}")

                # Save final auth state
                context.storage_state(path=str(self.state_file))
                
                print("Page successfully duplicated, moved, and renamed!")
                return duplicated_url
                
        except PlaywrightTimeoutError as e:
            print(f"Playwright timeout error: {e}")
            return None
        except Exception as e:
            print(f"Error during duplication: {e}")
            return None
    
    async def duplicate_page_with_mcp(self, child_page_id: str, target_parent_id: str, child_name: str) -> Optional[str]:
        # the functionlity is the same as with playwright but we use notion official mcp to do so
        notion_official_server = MCPServerManager(agent_workspace="./").servers['notion_official']
        async with notion_official_server as server:
            res = await call_tool_with_retry(server, "notion-duplicate-page", {"page_id": child_page_id})
            data = json.loads(res.content[0].text)

            # Check if duplication was successful
            if 'name' in data and data.get('name') == 'APIResponseError':
                error_body = json.loads(data.get('body', '{}'))
                error_msg = error_body.get('message', 'Unknown error')
                raise Exception(f"Failed to duplicate page: {error_msg}")

            duplicated_page_id = data['page_id']
            print(f"Duplicated page ID: {duplicated_page_id}")
            self.duplicated_page_id = duplicated_page_id
            print(f"Target parent ID: {target_parent_id}")
            # use notion api to check if the page is ready, if not we wait for 1s

            timeout = 600
            current_time = 0
            page_ready = False
            page_type = None
            while current_time < timeout:
                try:
                    page_info = self.notion_client.pages.retrieve(page_id=duplicated_page_id)
                    if page_info:
                        page_ready = True
                        page_type = page_info.get('object', 'unknown')
                        print(f"Page is ready! Object type: {page_type}")
                        break
                except Exception as e:
                    print(f"Page not ready! Waiting for 1s... Error: {e}")
                    time.sleep(1)
                    current_time += 1
            if not page_ready:
                raise Exception(f"Page not ready after {timeout} seconds!")

            # Additional check for page type
            if page_type != 'page':
                print(f"WARNING: Retrieved object type is '{page_type}', not 'page'. This might cause issues.")

            # Try to move the page with retry logic for "not ready" errors
            max_move_attempts = 8
            move_attempt = 0
            move_successful = False

            while move_attempt < max_move_attempts:
                move_attempt += 1

                try:
                    res = await call_tool_with_retry(server, "notion-move-pages", {
                            "page_or_database_ids": [duplicated_page_id],
                            "new_parent": {
                                "page_id":target_parent_id
                                }
                            }
                        )
                    data = json.loads(res.content[0].text)
                    print(data)

                    # Check if it's an error response
                    if 'name' in data and data.get('name') == 'APIResponseError':
                        error_body = json.loads(data.get('body', '{}'))
                        error_msg = error_body.get('message', 'Unknown error')
                        error_code = error_body.get('code', '')

                        # Check if it's a "not ready" error
                        if 'not a page or database' in error_msg.lower() or error_code == 'validation_error':
                            if move_attempt < max_move_attempts:
                                wait_time = 2 ** move_attempt # Exponential backoff: 2s, 4s, 8s, 16s, 32s, 64s, 128s, 256s, 512s, 1024s
                                print(f"Page not fully ready yet (attempt {move_attempt}/{max_move_attempts}). Waiting {wait_time}s before retry...")
                                time.sleep(wait_time)
                                continue

                        raise Exception(f"Failed to move the page: {error_msg}")

                    if 'result' not in data or not data['result'].startswith("Success"):
                        raise Exception(f"Failed to move the page: {data.get('result', 'No result returned')}")

                    # Success!
                    move_successful = True
                    break

                except Exception as e:
                    if move_attempt >= max_move_attempts:
                        raise
                    # For other exceptions, also retry
                    wait_time = move_attempt * 2
                    print(f"Move failed (attempt {move_attempt}/{max_move_attempts}): {e}")
                    print(f"Waiting {wait_time}s before retry...")
                    time.sleep(wait_time)

            if not move_successful:
                raise Exception(f"Failed to move the page after {max_move_attempts} attempts")
        self.rename_page_via_api(duplicated_page_id, child_name)
        return f"https://www.notion.so/{duplicated_page_id.replace('-', '')}"
        

    def duplicate_child_page(self, source_parent_url: str, child_name: str, target_parent_url: str, with_playwright=WITH_PLAYWRIGHT) -> bool:
        """
        Main function to duplicate a child page from source parent to target parent.
        
        Args:
            source_parent_url: URL of the source parent page
            child_name: Name of the child page to duplicate
            target_parent_url: URL of the target parent page
            
        Returns:
            True if successful, False otherwise
        """
        try:
            # Extract page IDs from URLs
            source_parent_id = self.extract_page_id_from_url(source_parent_url)
            target_parent_id = self.extract_page_id_from_url(target_parent_url)
            
            print(f"Source parent ID: {source_parent_id}")
            print(f"Target parent ID: {target_parent_id}")
            
            # Find the child page
            print(f"Looking for child page '{child_name}'...")
            child_info = self.find_child_page_by_name(source_parent_id, child_name)
            
            if not child_info:
                print(f"Error: Child page '{child_name}' not found under source parent")
                return False
            
            child_page_id, child_page_url = child_info
            print(f"Found child page: {child_page_id}")
            
            # Get target parent title for the move operation
            target_parent_title = self.get_page_title_by_id(target_parent_id)
            print(f"Target parent title: {target_parent_title}")
            
            # Duplicate the child page and move it to target parent
            if with_playwright:
                duplicated_url = self.duplicate_page_with_playwright(source_parent_url, child_page_url, target_parent_title, child_name)
            else:
                duplicated_url = asyncio.run(self.duplicate_page_with_mcp(child_page_id, target_parent_id, child_name))
            
            if duplicated_url:
                print(f"Success! Duplicated page URL: {duplicated_url}")
                return True
            else:
                print("Failed to duplicate the page")
                return False
                
        except Exception as e:
            print(f"Error in duplicate_child_page: {e}")
            return False

    def get_duplicated_page_id(self) -> Optional[str]:
        """Get the ID of the last duplicated page."""
        return self.duplicated_page_id

def save_page_id_to_file(page_id: str, file_path: str) -> bool:
    """
    Save the page ID to a specified file.
    
    Args:
        page_id: The page ID to save
        file_path: The file path where to save the ID
        
    Returns:
        True if successful, False otherwise
    """
    try:
        output_file = Path(file_path)
        # Create parent directories if they don't exist
        output_file.parent.mkdir(parents=True, exist_ok=True)
        
        # Write the page ID to the file
        output_file.write_text(page_id)
        print(f"Page ID saved to: {file_path}")
        return True
    except Exception as e:
        print(f"Error saving page ID to file: {e}")
        return False

def main():
    """Command line interface for the page duplicator."""
    parser = argparse.ArgumentParser(
        description="Duplicate a Notion child page from one parent to another",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    
    parser.add_argument(
        "--source-parent",
        required=True,
        help="URL of the source parent page",
    )
    
    parser.add_argument(
        "--child-name",
        required=True,
        help="Name of the child page to duplicate",
    )
    
    parser.add_argument(
        "--target-parent",
        required=True,
        help="URL of the target parent page",
    )
    
    parser.add_argument(
        "--notion-key",
        required=True,
        help="Notion API integration token",
    )
    
    parser.add_argument(
        "--output-file",
        help="File path to save the duplicated page ID (optional)",
    )
    
    parser.add_argument(
        "--browser",
        default="chromium",
        choices=["firefox", "chromium"],
        help="Browser to use for Playwright",
    )
    
    parser.add_argument(
        "--headless",
        action="store_true",
        default=True,
        help="Run browser in headless mode",
    )
    
    parser.add_argument(
        "--state-path",
        default="./configs/notion_state.json",
        help="The path to save the authenticated session state.",
    )
    
    args = parser.parse_args()
    
    try:
        duplicator = NotionPageDuplicator(
            notion_key=args.notion_key,
            browser=args.browser,
            headless=args.headless,
            state_path=args.state_path,
        )
        
        success = duplicator.duplicate_child_page(
            source_parent_url=args.source_parent,
            child_name=args.child_name,
            target_parent_url=args.target_parent,
        )
        
        if success:
            print("\n‚úÖ Page duplication completed successfully!")
            
            # Save the duplicated page ID to file if output file is specified
            if args.output_file:
                duplicated_id = duplicator.get_duplicated_page_id()
                if duplicated_id:
                    if save_page_id_to_file(duplicated_id, args.output_file):
                        print(f"‚úÖ Page ID '{duplicated_id}' saved to {args.output_file}")
                    else:
                        print(f"‚ö†Ô∏è Failed to save page ID to {args.output_file}")
                else:
                    print("‚ö†Ô∏è Could not retrieve duplicated page ID")
            
            exit(0)
        else:
            print("\n‚ùå Page duplication failed!")
            exit(1)
            
    except Exception as e:
        print(f"‚ùå Error: {e}")
        exit(1)

if __name__ == "__main__":
    main()